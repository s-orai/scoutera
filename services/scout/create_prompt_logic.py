from clients import gemini_client

def format_prompt(pdfs_A, pdfs_B, pdfs_C, comment_B, comment_C, job_title):
  return f"""
            あなたは優秀なリクルーターです。企業のリクルーターとして、添付した募集求人(ファイル名：{job_title})に対しての候補者にダイレクトスカウトを送信します。
            【PDFの扱いについて】
            ・ファイル名：{job_title}は募集求人として読み取ってください。
            ・ファイル名：{job_title}以外のファイルは候補者情報として読み取ってください。

            あなたには、以下に示す条件をもとに必須要件、歓迎要件の作成をしてもらいます。

            私は企業のリクルーターで、添付した求人に対してのダイレクトスカウトを運用しています。
            スカウトを送信するにあたり、まずは候補者のマッチ度をA,B,C評価し、A,B評価の候補者だけにスカウトを送信します。(C評価の候補者はスカウト対象外)
            評価の基準は以下の通りです。
            ・A評価：必須要件を満たし、かつ歓迎要件を一部以上満たす
            ・B評価：必須要件は満たすが、歓迎要件は一つも満たさない
            ・C評価：必須要件を一部でも満たさない

            この候補者のマッチ度評価するにあたり、まずは必須要件、歓迎要件を作成したいです。
            あなたは、A,B,C評価それぞれの候補者の経歴を見た上で、そのスキルの差分を言語化し、必須要件、歓迎要件を作成をしてください。

            ## 言語化する目的
            ・候補者のマッチ度評価をするにあたり、A,B,C評価の差分を明確にするため
            ・スカウト対象となる候補者の必須要件、歓迎要件をそれぞれ作成するため
            ### 必須要件とは
            ・候補者が求人に応募するにあたり、必ず持っていなければならないスキル・経験のことです
            ・A,B評価の候補者は満たしているが、C評価の候補者は満たしていない条件が必須要件に当たります
            ### 歓迎要件とは
            ・候補者が求人に応募するにあたり、持っていればより歓迎されるスキル・経験のことです
            ・A評価の候補者は満たしているが、B評価の候補者は満たしていない条件が歓迎要件に当たります

            ## 参考情報
            ### 求人
            ・ファイル「{job_title}」
            ### 候補者ファイルの説明
            ・ファイル「{pdfs_A}」:A評価の候補者リスト
            ・ファイル「{pdfs_B}」:B評価の候補者リスト
            ・ファイル「{pdfs_C}」:C評価の候補者リスト
            ### B評価になった候補者に対してのコメント
            ※ 以下のコメントは歓迎要件を作成するにあたって参考にしてください
            {comment_B}
            ### C評価になった候補者に対してのコメント
            ※ 以下のコメントは必須要件を作成するにあたって参考にしてください
            {comment_C}

            ## 必須要件・歓迎要件作成時の条件
            ・条件の大項目ごとに番号(1~)を振る
            ・小項目（より具体的な条件）があれば、大項目に付随する形で記載する
            ・例外があれば、小項目「以下の場合はC評価となる」を作成し、それに付随する形で条件を記載する
            ・「直近在籍の企業に1年以上勤めており、かつ在籍中である」は必ず大項目の条件として入れる
            ### 作成例
            1. 日本語能力がネイティブである
            2. 直近5年以上、oC/toB向け Webアプリケーションの開発実務経験がある
              - 以下の経験の場合はC評価となる
                - 社内システム・インフラ・汎用系が中心
                - 開発対象が **Windowsデスクトップアプリ, 汎用機システム, 組み込みシステム** に限定されている
            3. 以下のいずれかで実務レベルの経験があり、モダンな技術スタックの整合性がとれている
              - TS/React/Vue/Ruby/Django/GCPなど適合性が高い技術が中心
              - 以下の場合はC評価となる
                - メインの開発言語が **C#, VB.NET, ASP.NET, VBA, COBOL, C/C++ (組み込み/制御)** のみである。
            4. 直近、「実装」工程を担当している
              - 以下の場合はC評価となる
                - 担当工程が **「保守・運用（監視・障害対応）」のみ** で、機能追加開発を行っていない。
                - 担当工程が **「マネジメント・進捗管理・要件定義」のみ** で、直近（ここ1〜2年）の実装経験がない。
            5. 要件定義、基本設計など上流工程の経験が1年以上ある
            6. 直近在籍の企業に1年以上勤めており、かつ在籍中である

            -----
            以上を踏まえ、候補者のマッチ度評価を行うために、A,B,C評価それぞれの候補者のスキルの差分を言語化し、必須要件、歓迎要件を作成してください。
            結果は以下の項目を順番で出力してください。
            1. A評価の候補者が持っている共通のスキル
            2. A,B評価の候補者とC評価の候補者のスキルの差分
            3. A評価の候補者とB評価の候補者のスキルの差分
            4. 必須要件（箇条書きで出力）
            5. 歓迎要件（箇条書きで出力）

            【出力形式（必ずこの通りの純粋なJSONで出力）】
            {{
              "result": [
                {{
                  "common_skill_of_A": "A評価の候補者が持っている共通のスキル",
                  "difference_of_ab_and_c"： "A,B評価の候補者とC評価の候補者のスキルの差分",
                  "difference_of_a_and_b"： "A評価の候補者とB評価の候補者のスキルの差分",
                  "required_condition"： "必須要件（箇条書きで出力）",
                  "welcome_condition"： "歓迎要件（箇条書きで出力）",
                }}
              ]
            }}

            ・すべての候補者を this JSON の配列にまとめて返してください。
            ・これは最終出力であり、途中思考は出力しないでください。
            """


def create_list_by_gemini(pdfs_a, pdfs_b, pdfs_c, comment_b, comment_c, job_pdf, temperature):
  job_title = ""
  for _, original_name in job_pdf:
    job_title = original_name

  pdfs_a_titles = extract_original_name(pdfs_a)
  pdfs_b_titles = extract_original_name(pdfs_b)
  pdfs_c_titles = extract_original_name(pdfs_c)

  prompt = format_prompt(pdfs_a_titles, pdfs_b_titles, pdfs_c_titles, comment_b, comment_c, job_title)
  pdfs = pdfs_a + pdfs_b + pdfs_c
  result = gemini_client.request_for_create_prompt(prompt, pdfs, job_pdf, temperature)

  return result

def extract_original_name(pdfs):
  """
  一時ファイル情報のリストから元のファイル名だけを取り出してリストで返す。
  pdfs そのものは破壊的に変更しない。
  """
  names = []
  for _, original_name in pdfs:
    names.append(original_name)
  return names
